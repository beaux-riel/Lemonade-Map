{"version":3,"file":"Map-Bc-2hPcQ.js","sources":["../../../src/components/map/Map.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useMemo, memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport {\n  MapContainer,\n  TileLayer,\n  Marker,\n  Popup,\n  useMap,\n  ZoomControl,\n} from \"react-leaflet\";\nimport L from \"leaflet\";\nimport \"leaflet/dist/leaflet.css\";\nimport { useGeolocation } from \"../../contexts/GeolocationContext\";\nimport { isSecureContext } from \"../../services/geolocationService\";\n\n// Detect iOS for specific fixes\nL.Browser.safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nL.Browser.iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || \n                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\n\n// Fix for default marker icons in react-leaflet\n// This is needed because the default markers use relative paths that don't work in React\ndelete L.Icon.Default.prototype._getIconUrl;\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',\n  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',\n  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',\n});\n\n// Custom lemonade stand marker icon\nconst createLemonadeIcon = () => {\n  // Get the base URL from the window location\n  const baseUrl = window.location.origin;\n  return new L.Icon({\n    iconUrl: `${baseUrl}/images/markers/lemonade-marker.svg`,\n    iconSize: [40, 48],\n    iconAnchor: [20, 48],\n    popupAnchor: [0, -48],\n  });\n};\n\n// Custom user location marker icon\nconst createUserLocationIcon = () => {\n  // Get the base URL from the window location\n  const baseUrl = window.location.origin;\n  return new L.Icon({\n    iconUrl: `${baseUrl}/images/markers/user-location.svg`,\n    iconSize: [24, 24],\n    iconAnchor: [12, 12],\n    popupAnchor: [0, -12],\n  });\n};\n\n// Component to handle map view updates and iOS-specific fixes\nconst MapViewUpdater = ({ center, zoom }) => {\n  const map = useMap();\n\n  useEffect(() => {\n    if (center) {\n      map.setView(center, zoom);\n    }\n    \n    // Apply iOS-specific fixes\n    if (L.Browser.iOS) {\n      // Fix for iOS Safari map rendering issues\n      setTimeout(() => {\n        map.invalidateSize();\n      }, 100);\n      \n      // Fix for iOS momentum scrolling issues\n      const container = map.getContainer();\n      container.addEventListener('touchstart', (e) => {\n        if (e.touches.length === 1) {\n          e.stopPropagation();\n        }\n      }, { passive: false });\n    }\n  }, [center, zoom, map]);\n\n  return null;\n};\n\nMapViewUpdater.propTypes = {\n  center: PropTypes.arrayOf(PropTypes.number),\n  zoom: PropTypes.number,\n};\n\n// Component to handle user location - memoized to prevent unnecessary re-renders\nconst UserLocationMarker = memo(({ showUserLocation, onUserLocationFound }) => {\n  const [position, setPosition] = useState(null);\n  const [accuracy, setAccuracy] = useState(null);\n  const map = useMap();\n  const locationCircleRef = useRef(null);\n  const lastNotifiedPositionRef = useRef(null);\n  const { location, getLocation } = useGeolocation();\n\n  // Memoize the icon creation\n  const icon = useMemo(() => createUserLocationIcon(), []);\n\n  // Update position when location changes from context\n  useEffect(() => {\n    if (location && showUserLocation) {\n      const latlng = { lat: location.lat, lng: location.lng };\n      setPosition([latlng.lat, latlng.lng]);\n      setAccuracy(location.accuracy || 0);\n\n      // Create or update accuracy circle\n      if (locationCircleRef.current) {\n        locationCircleRef.current.setLatLng(latlng);\n        locationCircleRef.current.setRadius(location.accuracy || 100);\n      } else {\n        locationCircleRef.current = L.circle(latlng, {\n          radius: location.accuracy || 100,\n          color: \"#4285F4\",\n          fillColor: \"#4285F4\",\n          fillOpacity: 0.1,\n          weight: 1,\n        }).addTo(map);\n      }\n    }\n  }, [location, map, showUserLocation]); // Use location instead of position to avoid circular dependency\n  \n  // Separate useEffect for notifying parent to prevent infinite loops\n  useEffect(() => {\n    if (position && onUserLocationFound && showUserLocation) {\n      // Only notify parent once when position is first set or when it changes significantly\n      // This prevents infinite loops of re-centering and re-zooming\n      const latlng = { lat: position[0], lng: position[1] };\n      \n      // Only notify if position has changed significantly (more than 10 meters)\n      // or if this is the first time we're notifying\n      if (!lastNotifiedPositionRef.current || \n          Math.abs(lastNotifiedPositionRef.current.lat - latlng.lat) > 0.0001 || \n          Math.abs(lastNotifiedPositionRef.current.lng - latlng.lng) > 0.0001) {\n        \n        lastNotifiedPositionRef.current = latlng;\n        onUserLocationFound(latlng);\n      }\n    }\n  }, [position, showUserLocation, onUserLocationFound]);\n  \n  // Use Leaflet's locate method as a fallback - optimized to reduce unnecessary work\n  useEffect(() => {\n    if (!showUserLocation) {\n      if (locationCircleRef.current) {\n        locationCircleRef.current.remove();\n        locationCircleRef.current = null;\n      }\n      return;\n    }\n\n    // Check if we're in a secure context before trying to get location\n    if (!isSecureContext()) {\n      console.warn(\"Geolocation is not available in insecure contexts (non-HTTPS)\");\n      return;\n    }\n\n    // If we don't have a location from context, try to get it using Leaflet\n    if (!location) {\n      // Use a more efficient locate method for mobile\n      map.locate({\n        setView: true,\n        maxZoom: 16,\n        enableHighAccuracy: L.Browser.mobile, // Higher accuracy on mobile, especially for iOS\n        timeout: 15000, // Longer timeout for iOS\n        maximumAge: 30000, // Allow cached positions up to 30 seconds old\n        watch: L.Browser.mobile && L.Browser.safari, // Watch mode for iOS Safari\n      });\n\n      const onLocationFound = (e) => {\n        setPosition([e.latlng.lat, e.latlng.lng]);\n        setAccuracy(e.accuracy);\n\n        // Create or update accuracy circle\n        if (locationCircleRef.current) {\n          locationCircleRef.current.setLatLng(e.latlng);\n          locationCircleRef.current.setRadius(e.accuracy);\n        } else {\n          locationCircleRef.current = L.circle(e.latlng, {\n            radius: e.accuracy,\n            color: \"#4285F4\",\n            fillColor: \"#4285F4\",\n            fillOpacity: 0.1,\n            weight: 1,\n          }).addTo(map);\n        }\n\n        // We've moved the notification to a separate useEffect to prevent infinite loops\n      };\n\n      const onLocationError = (e) => {\n        console.error(\"Error getting location from Leaflet:\", e.message);\n        // Only try to get location using our geolocation service if we're in a secure context\n        if (isSecureContext()) {\n          getLocation();\n        }\n      };\n\n      map.on(\"locationfound\", onLocationFound);\n      map.on(\"locationerror\", onLocationError);\n\n      return () => {\n        map.off(\"locationfound\", onLocationFound);\n        map.off(\"locationerror\", onLocationError);\n      };\n    }\n\n    return () => {\n      if (locationCircleRef.current) {\n        locationCircleRef.current.remove();\n        locationCircleRef.current = null;\n      }\n    };\n  }, [map, showUserLocation, onUserLocationFound, location, getLocation]);\n\n  // Only render the marker if we have a position\n  return position ? (\n    <Marker position={position} icon={icon}>\n      <Popup>\n        <div>\n          <h3 className=\"font-display text-base\">Your Location</h3>\n          <p className=\"text-sm\">Accuracy: {Math.round(accuracy)} meters</p>\n        </div>\n      </Popup>\n    </Marker>\n  ) : null;\n});\n\nUserLocationMarker.propTypes = {\n  showUserLocation: PropTypes.bool,\n  onUserLocationFound: PropTypes.func,\n};\n\n// Memoized StandMarker component to prevent unnecessary re-renders\nconst StandMarker = memo(({ stand, onStandClick }) => {\n  // Memoize the icon creation\n  const icon = useMemo(() => createLemonadeIcon(), []);\n\n  return (\n    <Marker\n      key={stand.id}\n      position={[stand.location_lat, stand.location_lng]}\n      icon={icon}\n      eventHandlers={{\n        click: () => {\n          if (onStandClick) {\n            onStandClick(stand);\n          }\n        },\n      }}\n    >\n      <Popup>\n        <div className=\"text-center\">\n          <h3 className=\"font-display text-lg text-lemonade-yellow-dark\">\n            {stand.name}\n          </h3>\n          {stand.image_url && (\n            <img\n              src={stand.image_url}\n              alt={stand.name}\n              className=\"w-32 h-32 object-cover mx-auto my-2 rounded-lg\"\n              loading=\"lazy\" // Add lazy loading for images\n            />\n          )}\n          <p className=\"text-sm\">{stand.description}</p>\n          <p className=\"text-xs mt-2 text-gray-600\">{stand.address}</p>\n          <button\n            className=\"mt-2 px-3 py-1 bg-lemonade-yellow text-gray-800 rounded-full text-sm font-display hover:bg-lemonade-yellow-dark\"\n            onClick={(e) => {\n              e.stopPropagation();\n              if (onStandClick) {\n                onStandClick(stand);\n              }\n            }}\n          >\n            View Details\n          </button>\n        </div>\n      </Popup>\n    </Marker>\n  );\n});\n\nStandMarker.propTypes = {\n  stand: PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    name: PropTypes.string.isRequired,\n    description: PropTypes.string,\n    location_lat: PropTypes.number.isRequired,\n    location_lng: PropTypes.number.isRequired,\n    address: PropTypes.string,\n    image_url: PropTypes.string,\n  }).isRequired,\n  onStandClick: PropTypes.func,\n};\n\n/**\n * Map component for displaying lemonade stands\n */\nconst Map = ({\n  stands = [],\n  center = [49.2827, 123.1207], // Default to Vancouver, BC\n  zoom = 13,\n  height = \"500px\",\n  showUserLocation = true,\n  onStandClick,\n  onUserLocationFound,\n  className = \"\",\n  children,\n  ...props\n}) => {\n  // Memoize the stands array to prevent unnecessary re-renders\n  const memoizedStands = useMemo(() => stands, [stands]);\n\n  return (\n    <div\n      className={`rounded-xl overflow-hidden shadow-playful lemonade-map-container ${className}`}\n      style={{ height }}\n      {...props}\n    >\n      <MapContainer\n        center={center}\n        zoom={zoom}\n        style={{ height: \"100%\", width: \"100%\" }}\n        zoomControl={false}\n        // Add performance optimizations for mobile\n        preferCanvas={true}\n        attributionControl={false}\n        minZoom={2}\n        maxZoom={50}\n        updateWhenZooming={false}\n        updateWhenIdle={true}\n        tap={true} // Enable tap for mobile\n        dragging={!L.Browser.mobile ? true : true} // Ensure dragging works on mobile\n        touchZoom={true} // Enable touch zoom for mobile\n        doubleClickZoom={true}\n        scrollWheelZoom={true}\n        keyboard={true}\n        bounceAtZoomLimits={false} // Prevent bounce effect at zoom limits on iOS\n        // iOS-specific fixes\n        tapTolerance={15} // Increase tap tolerance for iOS\n        wheelDebounceTime={100} // Debounce wheel events\n      >\n        <TileLayer\n          attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        />\n\n        <ZoomControl position=\"bottomright\" />\n\n        {/* Update map view when center or zoom changes */}\n        <MapViewUpdater center={center} zoom={zoom} />\n\n        {/* Show user location if enabled */}\n        <UserLocationMarker\n          showUserLocation={showUserLocation}\n          onUserLocationFound={onUserLocationFound}\n        />\n\n        {/* Render lemonade stand markers */}\n        {memoizedStands.map((stand) => (\n          <StandMarker\n            key={stand.id}\n            stand={stand}\n            onStandClick={onStandClick}\n          />\n        ))}\n        \n        {/* Render children components (like DraggableMarker) */}\n        {children}\n      </MapContainer>\n    </div>\n  );\n};\n\nMap.propTypes = {\n  stands: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      name: PropTypes.string.isRequired,\n      description: PropTypes.string,\n      location_lat: PropTypes.number.isRequired,\n      location_lng: PropTypes.number.isRequired,\n      address: PropTypes.string,\n      image_url: PropTypes.string,\n    })\n  ),\n  center: PropTypes.arrayOf(PropTypes.number),\n  zoom: PropTypes.number,\n  height: PropTypes.string,\n  showUserLocation: PropTypes.bool,\n  onStandClick: PropTypes.func,\n  onUserLocationFound: PropTypes.func,\n  className: PropTypes.string,\n  children: PropTypes.node,\n};\n\nexport default Map;\n"],"names":["L","Browser","safari","test","navigator","userAgent","iOS","platform","maxTouchPoints","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","iconUrl","shadowUrl","MapViewUpdater","center","zoom","map","useMap","useEffect","setView","setTimeout","invalidateSize","getContainer","addEventListener","e","touches","length","stopPropagation","passive","propTypes","PropTypes","arrayOf","number","UserLocationMarker","memo","showUserLocation","onUserLocationFound","position","setPosition","useState","accuracy","setAccuracy","locationCircleRef","useRef","lastNotifiedPositionRef","location","getLocation","useGeolocation","icon","useMemo","baseUrl","window","origin","iconSize","iconAnchor","popupAnchor","createUserLocationIcon","latlng","lat","lng","current","setLatLng","setRadius","circle","radius","color","fillColor","fillOpacity","weight","addTo","Math","abs","isSecureContext","locate","maxZoom","enableHighAccuracy","mobile","timeout","maximumAge","watch","onLocationFound","onLocationError","on","off","remove","Marker","children","jsx","Popup","className","jsxs","round","bool","func","StandMarker","stand","onStandClick","createLemonadeIcon","jsxRuntimeExports","location_lat","location_lng","eventHandlers","click","name","image_url","src","alt","loading","description","address","onClick","id","shape","string","isRequired","Map","stands","height","props","memoizedStands","style","MapContainer","width","zoomControl","preferCanvas","attributionControl","minZoom","updateWhenZooming","updateWhenIdle","tap","dragging","touchZoom","doubleClickZoom","scrollWheelZoom","keyboard","bounceAtZoomLimits","tapTolerance","wheelDebounceTime","TileLayer","attribution","url","ZoomControl","node"],"mappings":"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"}